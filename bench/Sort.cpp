// Autogenerated by MCQC
#pragma once
#include "bool.hpp"
#include "nat.hpp"
#include "option.hpp"
#include "io.hpp"
#include "show.hpp"
#include "variant.hpp"

using namespace Bool;
using namespace Nat;
using namespace Option;
using namespace Io;
using namespace Show;
using namespace Variant;

template<class T>
struct Coq_nil {};
template<class T>
struct Coq_cons {
  T a;
  std::shared_ptr<std::variant<Coq_nil<T>, Coq_cons<T>>> b;
  Coq_cons(T a, std::shared_ptr<std::variant<Coq_nil<T>, Coq_cons<T>>> b) {
    this->a = a;
    this->b = b;
  };
};

template<class T>
using list = std::variant<Coq_nil<T>, Coq_cons<T>>;

template<class T>
std::shared_ptr<list<T>> coq_nil() {
  return std::make_shared<list<T>>(Coq_nil<T>());
}

template<class T>
std::shared_ptr<list<T>> coq_cons(T a, std::shared_ptr<list<T>> b) {
  return std::make_shared<list<T>>(Coq_cons<T>(a, b));
}

template<class T, class U, class V>
auto match(std::shared_ptr<list<T>> self, U f, V g) {
  return gmatch(self, [=](Coq_nil<T> _) { return f(); }, [=](Coq_cons<T> _) { return g(_.a, _.b); });
}

template<class T>
std::shared_ptr<list<T>> app(std::shared_ptr<list<T>> l, std::shared_ptr<list<T>> m) {
  return match(l,   [=]() { return m; },
                    [=](auto a, auto l1) { return coq_cons<T>(a, app<T>(l1, m)); });
}

template<class T>
std::shared_ptr<list<T>> rev(std::shared_ptr<list<T>> l) {
  return match(l,
    [=]() { return coq_nil<T>(); },
    [=](auto x, auto lM) { return app<T>(rev<T>(lM), coq_cons<T>(x, coq_nil<T>())); });
}

std::shared_ptr<list<nat>> merge(std::shared_ptr<list<nat>> l1, std::shared_ptr<list<nat>> l2) {
  return match(l1,
    [=]() { return l2; },
    [=](auto a1, auto l1M) { return match(l2,
      [=]() { return l1; },
      [=](auto a2, auto l2M) { return match(a1 <= a2,
        [=]() { return coq_cons<nat>(a1, merge(l1M, l2)); },
        [=]() { return coq_cons<nat>(a2, merge(l1, l2M)); }); }); });
}

std::shared_ptr<list<nat>> merge_stack(std::shared_ptr<list<option<list<nat>>>> stack) {
  return match(stack,
    [=]() { return coq_nil<nat>(); },
    [=](auto y, auto stackM) { return match(y,
      [=](auto l) { return merge(std::make_shared<list<nat>>(l), merge_stack(stackM)); },
      [=]() { return merge_stack(stackM); });
    });
}

std::shared_ptr<list<nat>> flatten_stack(std::shared_ptr<list<option<list<nat>>>> stack) {
  return match(stack,
    [=]() { return coq_nil<nat>(); },
    [=](auto o, auto stackM) { return match(o,
      [=](auto l) { return app<nat>(std::make_shared<list<nat>>(l), flatten_stack(stackM)); },
      [=]() { return flatten_stack(stackM); }); });
}

std::shared_ptr<list<nat>> series(nat n) {
  return match(n,
    [=]() { return coq_nil<nat>(); },
    [=](auto m) { return coq_cons<nat>(n, series(m)); });
}

std::shared_ptr<list<option<list<nat>>>> merge_list_to_stack(std::shared_ptr<list<option<list<nat>>>> stack, std::shared_ptr<list<nat>> l) {
  return match(stack,
    [=]() { return coq_cons<option<list<nat>>>(some(*l), coq_nil<option<list<nat>>>()); },
    [=](auto y, auto stackM) { return match(y,
      [=](auto lM) { return coq_cons<option<list<nat>>>(none<list<nat>>(), merge_list_to_stack(stackM, merge(std::make_shared<list<nat>>(lM), l))); },
      [=]() { return coq_cons<option<list<nat>>>(some(*l), stackM); }); });
}

std::shared_ptr<list<nat>> iter_merge(std::shared_ptr<list<option<list<nat>>>> stack, std::shared_ptr<list<nat>> l) {
  return match(l,
    [=]() { return merge_stack(stack); },
    [=](auto a, auto lM) { return iter_merge(merge_list_to_stack(stack, coq_cons<nat>(a, coq_nil<nat>())), lM); });
}

std::shared_ptr<list<nat>> sort(std::shared_ptr<list<nat>> l) {
  return iter_merge(coq_nil<option<list<nat>>>(), l);
}

int main(int argc, char** argv) {
  auto test = series((nat)atoi(argv[1]));
  print(string("Sorted"));
  print(show(sort(test)));
  return 0;
}
