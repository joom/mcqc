// Autogenerated by MCQC
#pragma once
#include "nat.hpp"
#include "io.hpp"
#include "show.hpp"
#include "variant.hpp"

using namespace Nat;
using namespace Io;
using namespace Show;
using namespace Variant;

template<class T>
struct Coq_nil {};
template<class T>
struct Coq_cons {
  T a;
  std::shared_ptr<std::variant<Coq_nil<T>, Coq_cons<T>>> b;
  Coq_cons(T a, std::shared_ptr<std::variant<Coq_nil<T>, Coq_cons<T>>> b) {
    this->a = a;
    this->b = b;
  };
};

template<class T>
using list = std::variant<Coq_nil<T>, Coq_cons<T>>;

template<class T>
std::shared_ptr<list<T>> coq_nil() {
  return std::make_shared<list<T>>(Coq_nil<T>());
}

template<class T>
std::shared_ptr<list<T>> coq_cons(T a, std::shared_ptr<list<T>> b) {
  return std::make_shared<list<T>>(Coq_cons<T>(a, b));
}

template<class T, class U, class V>
auto match(std::shared_ptr<list<T>> self, U f, V g) {
  return gmatch(self, [=](Coq_nil<T> _) { return f(); }, [=](Coq_cons<T> _) { return g(_.a, _.b); });
}

template<class T>
std::shared_ptr<list<T>> app(std::shared_ptr<list<T>> l, std::shared_ptr<list<T>> m) {
  return match(l,   [=]() { return m; },
                    [=](auto a, auto l1) { return coq_cons<T>(a, app<T>(l1, m)); });
}

template<class T>
std::shared_ptr<list<T>> rev(std::shared_ptr<list<T>> l) {
  return match(l,
    [=]() { return coq_nil<T>(); },
    [=](auto h, auto ts) { return app<T>(rev<T>(ts), coq_cons<T>(h, coq_nil<T>())); });
}

std::shared_ptr<list<nat>> series(nat n) {
  return match(n,
    [=]() { return coq_nil<nat>(); },
    [=](auto m) { return coq_cons<nat>(n, series(m)); });
}

int main(int argc, char** argv) {
  auto test = series((nat)atoi(argv[1]));
  print(string("Reversed"));
  print(show(rev(test)));
  return 0;
}
